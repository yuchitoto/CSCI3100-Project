\chapter{Lesson Learned}
In this project, we have followed the waterfall software development model in the start, but we have gradually changed to agile and kanban model. In the coding stage, the back-end team have finished different modules and verified their correctness. Yet, the a part of the front-end team failed to finish their part according to schedule. This hindered the process, and we would not be able to proceed if we continued following the waterfall model as we should not proceed to integration stage if we have not finished the last module. In this project, we have found a major concern of waterfall model, is that waterfall model is not so flexible when only a part of the project is delayed. However, when a hybrid of kanban and agile model is adopted in later stage, the testing and integration advanced faster as the system allows more flexibility and enhancement without re-evaluating the requirements.

~

Another lesson learnt is that the deadline of schedule should be set much earlier than the actual deadline. Because it is likly that a part of your project delayed or even have no sign that it has been worked on by the person whom are supposed to do. By setting an earlier deadline in schedule, it is more likly that we can mend and finish the unworked part on time. Thus a higher software quality can be acheived.

~

If we can re-do the project, we would rewrite the whole schedule with earlier deadline of each phase of development. Moreover, instead of using waterfall model, kanban development model will be adopted from the start of the project. This is to handle the problem of inflexibility of waterfall model and the progress of each task is visualised and open. Therefore if we have adopted kanban development model, tasks will be handled in a better pace as we can know which tasks is being worked on.

~

Currently, the system is currently on version 1.0.1, yet there are many features designed was not implemented. For example, peer rating of posts, ordering of posts according to hit rate and tag system. Direct loading of code generated by visualised code editor, and loading of pre-written libraries for customized functions for rapid prototyping. Another feature planned but not implemented is code result comparison with expected output provided. This implies that there are still a lot of room for improvement as we have a lot of advance features not implemented yet. If we have more time, and a better planned schedule, we would continue on implementing the features and improve user experiences.

\chapter{Conclusion}
The Block Code Online IDE is designed to provide a dedicated online platform for programmers to exchange knowledge and source code. We believe only with exchange of ideas will allow a better result. Thus this dedicated platform is designed. The platform has a forum for programmers to share their code, and discuss about it. The platform also allows users to run codes on this platform, so that people can use other's codes more easily. A visualised code editor is also implemented in the system, so that programming beginners can learn coding using it more easily. The implementation and system architecture of the Block Code Online IDE followed the UML diagrams described above, thus with its OOP programming architecture and highly modularized design, it is highly adaptable to future changes. And the system is thoroughly tested, with protection against SQL injection. Therefore, our Block Code Online IDE is a user-friendly, reliable, secure, adaptative and functional system for programmers to use.
